#!/usr/bin/env python
# -*- coding: utf-8 -*-

# fetchserver/login.py
''' Negotiate AES key and HMAC key with client '''


from struct import pack
import hashlib
import logging
import os
import sys
import time
import wsgiref.handlers
from Crypto import Random
from PycryptoWrap import PRF
from PycryptoWrap import Tiger
from google.appengine.api import memcache
from google.appengine.ext import webapp


scriptpath = os.path.abspath(os.path.dirname(sys.argv[0]))
peerconf = os.path.join(scriptpath, 'peers.conf')
KEYLIFE = 3600 * 2  # AES/HMAC keys expire in 2 hours


def dprint(msg, prefix='Debug: '):
    """print debug info on SDK console"""
    logging.info(prefix + msg)


def get_config():
    '''parse the configure file, return a dictionary of preconfigured
    shapes and locations'''
    import ConfigParser
    config = ConfigParser.ConfigParser()
    config.readfp(open(peerconf))

    res = {'self': {'priv': ''}, 'users': {}}

    for sec in config.sections():
        if 'self' in sec:
            res['self']['priv'] = config.get(sec, 'priv')

        elif 'user' in sec:
            vname = config.get(sec, 'name')
            res['users'][vname] = config.get(sec, 'pub')

    return res


class ProtocolAbort(Exception):
    pass


class ServerHello(Tiger):
    """server reply to client request"""

    def onestep(self, msg):
        """Received a onestep client hello message, which formatted as:
        session_id + RSA(aes keys) + AES(username)

        the sever will find the stored client public key, use it to encrypt a
        newly generated aes key set, then encapsule it by encrypt it using the
        first aes key generated by the client

        if above fail, the server will remain silent

        """
        runtime_config = get_config()
        self.runtime_config = runtime_config
        self.rsa_priv = self.import_key(open(runtime_config['self']['priv']))
        self.sign_priv = self.import_sign_key(
                                        open(runtime_config['self']['priv']))
        self.rsa_pubs = {}
        self.sign_pubs = {}
        for user, pub in runtime_config['users'].iteritems():
            self.rsa_pubs[user] = self.import_key(open(pub))
            self.sign_pubs[user] = self.import_sign_key(open(pub))

        srv_random = (pack('<i', time.time()) + Random.get_random_bytes(28))

        rsa_d = self.rsa_priv.decrypt(msg[:Tiger.RSAOBJ_SIZE])
        client_rsa_sign = msg[Tiger.RSAOBJ_SIZE:]

        user_name = rsa_d[:20].strip()
        pre_master_secret = rsa_d[20:68]
        client_random = rsa_d[68:]

        if not self.verify(self.sign_pubs[user_name], rsa_d, client_rsa_sign):
            print 'Signature of Client Hello Message is wrong'
            return None

        s_id = Random.get_random_bytes(Tiger.SID_SIZE)

        master_secret = PRF(pre_master_secret, 'master secret',
                            client_random + srv_random, 48)

        hshk = s_id + client_random + srv_random + pre_master_secret
        hshk_hash = hashlib.sha256(hshk).digest()
        verify_data = PRF(master_secret, 'server finished',
                          hshk_hash, 32)
        payload = srv_random + s_id + verify_data

        rsa_e = self.rsa_pubs[user_name].encrypt(payload)
        srv_rsa_sign = self.sign(self.sign_priv, payload)

        key_block_size = (Tiger.SKEY_SIZE + Tiger.HMACKEY_SIZE) * 2
        key_block = PRF(master_secret, 'key expansion',
                        client_random + srv_random, key_block_size)

        # append timestamp to the end of key_block
        key_block += pack('<i', int(time.time())+ KEYLIFE)
        memcache.set(key=s_id, value=key_block)

        srv_finish = rsa_e + srv_rsa_sign
        return srv_finish


class Handshake(webapp.RequestHandler, ServerHello):

    TEST_PAGE = '''<HTML><HEAD><TITLE>Test Page</TITLE></HEAD>
    <BODY> <H1>It Worked!</H1>
    If you can see this, then your installation was successful.
    <P></BODY></HTML>'''

    def get(self):
        self.response.headerlist = [('Content-type', 'text/html')]
        self.response.out.write(self.TEST_PAGE)
        return

    def post(self):
        msg = self.request.body
        srv_resp = self.onestep(msg)
        if srv_resp:
            self.response.headers["Content-Type"] = "application/octet-stream"
            self.response.out.write(srv_resp)
        else:
            self.response.status = 404
            self.response.headerlist = [('Content-type', 'text/html')]
            self.response.out.write('Oops')


def main():
    application = webapp.WSGIApplication([('/login.html', Handshake),])
    wsgiref.handlers.CGIHandler().run(application)


if __name__ == "__main__":
    main()
